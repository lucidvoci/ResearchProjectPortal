#! /usr/bin/python

"""
This module contains converters from rrs db model (rrslib.db.model) into rrs-xml
format and back from rrs-xml into objects. RRS-XML format was designed for usage
in ReReSearch system as platform- and language-independet model.

The converters are using for parsing XML the SAX approach to gain maximum
efficiency even during processing large files. Algorithm for translation objects
into xml is recursive.

Actual database schema is available on
https://merlin.fit.vutbr.cz/nlp-wiki/index.php/Rrs_db

Specification of RRS-XML format is available on
https://merlin.fit.vutbr.cz/nlp-wiki/index.php/Rrs_moduleapi
"""

from rrslib.db.model import _UnknownType, _RRSDatabaseEntity, _RRSDbEntityRelationship
from rrslib.db.model import __tables__ as db_tables
from rrslib.db.model import __dbversion__ as model__dbversion__
import rrslib.db.model as dbmodel
from rrslib.xml.sax import SAXContentWriter
import sys
import time
from xml.sax import make_parser
import xml.sax.handler as saxhandler
import difflib
import re
import StringIO
import random

__modulename__ = "xmlconverter"
__author__="Stanislav Heller"
__email__="xhelle03@stud.fit.vutbr.cz"
__date__ ="$29.1.2011 22:18:14$"
__dbversion__ = model__dbversion__



class RRSXMLConverterError(Exception):
    pass

#-------------------------------------------------------------------------------
# End of class RRSXMLConverterError
#-------------------------------------------------------------------------------

class Model2XMLConverter(object):
    """
    Functionality of this class allows to convert hierarchical object model of
    RRS database (module rrslib.db.model) to RRS-XML format.

    If translating object with some new attributes unknown to model (in model
    they are specified as type _UnknownType, the converter will omit these
    attributes.
    """
    def __init__(self, stream=sys.stdout):
        self.stream = stream
        self.xmlparser = SAXContentWriter(stream)
        self.xmlparser.startDocument()
        self._add_comment()
        self.xmlparser.startElement("output")
        self._labels = {}


    def _add_comment(self):
        c = "\nOrigin: This XML was generated by Model2XMLConverter\n"
        c += "Format: $RRS-XML$\n"
        c += "Time:   $%s$\n" % time.ctime()
        self.xmlparser.comment(c)


    def _resolve_obj_name(self, obj):
        clsname = str(obj.__class__).split("'")[1].split(".")[-1]
        return clsname[3:].lower()


    def _get_obj_attrs(self, obj):
        a = {}
        for attr in ("id", "credibility", "module"):
            if obj.isset(attr):
                xmlattr = attr
                objattr = attr
                if attr == "module":
                    xmlattr = "source-module"
                a[xmlattr] = str(obj.get(objattr))
        return a


    def _get_role(self, attrstr):
        role = None
        tagname = attrstr
        if "_" in attrstr:
            # if not in tables, it has a probably a role
            if attrstr not in db_tables:
                sp = attrstr.split("_")
                tagname = "_".join(sp[:-1])
                # if it wasnt a role, but attribute with underscore
                if tagname not in db_tables:
                    tagname = "_".join(sp[1:])
                    if tagname not in db_tables:
                        return (attrstr, None)
                    return (tagname, sp[0])
                role = sp[-1]
        if attrstr == "publisher":
            return ('organization', attrstr)
        return (tagname, role)


    def _convert_raw_attribute(self, obj, attrstr):
        # create element
        if obj.isset(attrstr):
            if isinstance(obj, _RRSDbEntityRelationship):
                attr = obj.get_attribute(attrstr)
            else:
                attr = obj.get(attrstr)
            val = attr
            tagname, role = self._get_role(attrstr)
            if type(attr) == bool:
                if attr:
                    val = 'yes'
                else:
                    val = 'no'
            val = self._unicode(val)
            d = {"value": val}
            if role is not None:
                d['role'] = role
            self.xmlparser.startElement(tagname, d)
            self.xmlparser.endElement()

    def _hash(self):
        while 1:
            h = "".join([hex(random.randint(0,16)).lstrip("0x") for x in range(0,5)])
            if h in self._labels.values(): continue
            return h


    def _unicode(self, string):
        if isinstance(string, unicode):
            return string
        return unicode(str(string), encoding='utf-8')


    def _conversion(self, obj, role=None, add_relation_attributes={}):
        if not isinstance(obj, _RRSDatabaseEntity):
            raise  RRSXMLConverterError("Error while conversion model->rrs-xml. " \
                                        "Failed to convert %s", (str(type(obj))))
        name = self._resolve_obj_name(obj)
        attrs = self._get_obj_attrs(obj)
        if role is not None:
            attrs['role'] = role
        for k in add_relation_attributes:
            attrs[k] = self._unicode(add_relation_attributes[k])
        # create label or ref
        if obj in self._labels:
            attrs['ref'] = self._labels[obj]
            self.xmlparser.startElement(self._unicode(name), attrs)
            self.xmlparser.endElement()
            return
        else:
            hsh = self._hash()
            self._labels[obj] = hsh
            attrs['label'] = hsh
        self.xmlparser.startElement(self._unicode(name), attrs)
        for attrstr in obj.__dict__:
            if attrstr in ("__types__", "id", "credibility", "module", "lev", "_table_name"):
                continue
            # pass all unknown attributes
            if attrstr in obj.__types__ and obj.__types__[attrstr] == _UnknownType:
                continue
            attr = getattr(obj, attrstr)

            # handle junction objects (abstraction of N:N junc. tables)
            # these are represented by RRSRelationship***** objects
            if type(attr) is list:
                # iterate over all Relationship objects in list
                _, role = self._get_role(attrstr)
                for item in attr:
                    raw_rel_attrs = {}
                    # add all attributes of the relationship
                    for entattrstr in item.__dict__:
                        if entattrstr in ("__types__", "_parent", "_entities"):
                            continue
                        entattr = getattr(item, entattrstr)
                        if entattr is not None:
                            raw_rel_attrs[entattrstr] = str(entattr)
                        #if isinstance(entattr, _RRSDatabaseEntity):
                        #    self._conversion(entattr)
                        #else:
                        #    self._convert_raw_attribute(item, entattrstr)
                    # iterate over all entities of relation (i.e Publication and Project)
                    for ent in item._entities:
                        self._conversion(ent, role=role, add_relation_attributes=raw_rel_attrs)
            elif isinstance(attr, _RRSDatabaseEntity):
                _ , role = self._get_role(attrstr)
                self._conversion(attr, role=role)
            else:
                self._convert_raw_attribute(obj, attrstr)

        self.xmlparser.endElement()


    def convert(self, *args):
        """
        Converts hierarchical object model of RRS database to rrs-xml format in
        order of RRS-XML specification on
        https://merlin.fit.vutbr.cz/nlp-wiki/index.php/Rrs_moduleapi
        """
        self._labels = {} # clean labels
        # if obj is sequence or list or some iterable, go through
        for obj in args:
            if isinstance(obj, list):
                for o in obj:
                    o.compile()
                    self._conversion(o)
            else:
                obj.compile()
                self._conversion(obj)
        self.xmlparser.endDocument()

#-------------------------------------------------------------------------------
# End of class Model2XMLConverter
#-------------------------------------------------------------------------------


class _SAXModelGenerator(saxhandler.ContentHandler):
    """
    Helper class handling SAX-events to create model.

    This is private class, please do not touch, do not instantiate.
    """
    def __init__(self):
        saxhandler.ContentHandler.__init__(self)
        self._table_to_class_map = {}
        self._create_map()
        self.init()


    def init(self):
        self.model = []
        self.pointer = None
        self.buffer = []
        self._labels = {}
        self.role = None


    # ContentHandler methods
    def startElement(self, name, attrs):
        # parsing wrapper tag, omitted
        if name in ("input", "output"):
            return

        # if it is entity
        if name in self._table_to_class_map:
            # before creating new object, check if the tag has some label
            if "ref" in attrs:
                # get the existing object
                try:
                    obj = self._labels[attrs["ref"]]
                except:
                    raise RRSXMLConverterError("Invalid XML format: No label '%s'"\
                                               " in the tree. When referencing"\
                                               " some entity, there has to be "\
                                               "equivalent label." % attrs["ref"])
            else:
                # create new object
                obj = self._table_to_class_map[name]()
                if "label" in attrs:
                    self._labels[attrs["label"]] = obj
            relation_attr = {}
            for a in attrs.keys():
                if a == "role":
                    self.role = attrs[a]
                    continue
                obj_a = a
                attr_a = a
                if a == "source-module":
                    obj_a = "module"
                if not obj_a in obj.__types__:
                    # save junction table attributes
                    relation_attr[obj_a] = attrs[attr_a]
                    continue
                _type = obj.__types__[obj_a]
                if _type == basestring:
                    obj.set(obj_a, attrs[attr_a])
                else:
                    # cast value to appropriate type
                    if _type is bool:
                        rl_val = False
                        if (attrs[attr_a]).lower() == "yes":
                            rl_val = True
                    else:
                        rl_val = (_type)(attrs[attr_a])
                    obj.set(obj_a, rl_val)

            # if we just finished processing of some entity
            if self.pointer is None:
                self.pointer = obj
                self.model.append(obj)

            # there is some sub-entity, need to costruct relationship object
            else:
                attr = name
                if self.role is not None:
                    attr += "_" + self.role
                real_attr, _ = self._attr_translate(self.pointer, attr)
                reverse_attr = None
                unreal_rev_attr = self.pointer._table_name
                if self.role is not None:
                    unreal_rev_attr += "_" + self.role
                if real_attr not in ("type", "series"):
                    reverse_attr, cred = self._attr_translate(obj, unreal_rev_attr)
                    if cred < 90: reverse_attr = None
                
                # get relationship class
                rel_cls = self._get_rel_cls(name)
                # instantiate it
                relation, reverse_relation = rel_cls(), rel_cls()
                for a in relation:
                    if a in relation_attr:
                        _type = relation.__types__[a]
                        # cast value to appropriate type
                        if _type is bool:
                            rl_val = False
                            if (relation_attr[a]).lower() == "yes":
                                rl_val = True
                            relation[a] = rl_val
                            reverse_relation[a] = rl_val
                        elif _type == basestring:
                            relation[a] = relation_attr[a]
                            reverse_relation[a] = relation_attr[a]
                        else:
                            relation[a] = (_type)(relation_attr[a])
                            reverse_relation[a] = (_type)(relation_attr[a])
                if type(self.pointer[real_attr]) == list:
                    # set this entity into rel-obj
                    relation.set_entity(obj)
                    self.pointer.set(real_attr, relation)

                    # make it double-bounded
                    if reverse_attr is not None:
                        if type(obj[reverse_attr]) == list:
                            reverse_relation.set_entity(self.pointer)
                            obj.set(reverse_attr, reverse_relation)
                        else:
                            obj.set(reverse_attr, self.pointer)

                else:
                    self.pointer.set(real_attr, obj)
                    
                    # make it double-bounded
                    if reverse_attr is not None:
                        if type(obj[reverse_attr]) == list:
                            reverse_relation.set_entity(self.pointer)
                            obj.set(reverse_attr, reverse_relation)
                        else:
                            obj.set(reverse_attr, self.pointer)

                self.buffer.append(self.pointer) # push parent object to stack
                self.pointer = obj # get recursed
                self.role = None # clear role for next time

        # otherwise it is some attribute
        else:
            try:
                val = attrs["value"]
            except:
                raise RRSXMLConverterError("Invalid XML format: unknown tag '%s'" % name)
            if not self._contains_text(val):
                return
            if self.pointer.__types__[name] == dbmodel.RRSEmail:
                val = dbmodel.RRSEmail(val)
            elif self.pointer.__types__[name] == dbmodel.RRSDateTime:
                d = dbmodel.RRSDateTime()
                d.parse_isoformat(val)
                val = d
            else:
                _type = self.pointer.__types__[name]
                # cast value to appropriate type
                if _type == basestring:
                    self.pointer.set(name, val)
                elif _type is bool:
                    rl_val = False
                    if (val).lower() == "yes":
                        rl_val = True
                    self.pointer.set(name, rl_val)
                else:
                    # cast value to appropriate type
                    self.pointer.set(name, (_type)(val))
                return
            self.pointer.set(name, val)


    def endElement(self, name):
        if name in self._table_to_class_map:
            if not self.buffer:
                self.pointer = None
            else:
                self.pointer = self.buffer.pop()


    # support methods
    def _contains_text(self, txt):
        if not len(txt): return False
        s = re.sub("[\n\t\r ]+", "", txt)
        if not len(s): return False
        return True


    def _create_map(self):
        for item in dir(dbmodel):
            if not item.startswith("RRS"):
                continue
            cls = getattr(dbmodel, item)
            if not issubclass(cls, _RRSDatabaseEntity):
                if not issubclass(cls, dbmodel._RRSDbEntityRelationship):
                    continue
            self._table_to_class_map[cls._table_name] = cls


    def _get_rel_cls(self, name):
        usc_m = "_" # underscore multiplier
        tbl1, tbl2 = self.pointer._table_name, name
        if "_" in tbl1:
            usc_m = "__"
        else:
            tbl1 = tbl1[:4]
        if "_" in tbl2:
            usc_m = "__"
        else:
            tbl2 = tbl2[:4]
        # create possible junction table names
        rel_tbls = ["j" + usc_m + tbl1 + usc_m + tbl2,
                    "j" + usc_m + tbl2 + usc_m + tbl1]
        if self.role is not None:
            # add role to j_table names if needed
            for i in range(0,len(rel_tbls)):
                rel_tbls[i] += usc_m + self.role
        rel_cls = None
        # resolve relationship class
        for j in rel_tbls:
            if j in self._table_to_class_map:
                rel_cls = self._table_to_class_map[j]
                break

        # XXX this part is very tricky.
        # Because in database schema there is some inconstistency between names
        # of junction tables, it has to be done heuristical comparsion between
        # created - and probably bad - junction table name with real j_table
        # names and choosen is the most similar pair. Similarity is computed
        # with difflib.SequenceMatcher.ratio() method
        #
        # This algorithm is deterministic and always returns result, so we dont
        # need to be worry about rsl_cls == None.
        if rel_cls is None:
            ratios = {}
            for tbl in self._table_to_class_map.keys():
                for rel_tbl in rel_tbls:
                    s = difflib.SequenceMatcher(None, tbl, rel_tbl)
                    ratios[s.ratio()] = tbl
            m = max(ratios.keys())
            rel_cls = self._table_to_class_map[ratios[m]]
        return rel_cls


    def _attr_translate(self, obj, attr):
        cred = 100
        objattrs = [x for x in obj]
        if attr in objattrs:
            return (attr, cred)
        reversed = None
        if "_" in attr:
            sp = attr.split("_")
            reversed = sp[1] + "_" + sp[0]
            if reversed in objattrs:
                return (reversed, cred)
            r_strp = sp[1].rstrip("d") + "_" + sp[0]
            if r_strp in objattrs:
                return (r_strp, cred)
        if "type" in attr:
            return ("type", cred)
        if attr == obj._table_name:
            return ("parent", cred)
        # try to get most probable result
        ratios = {}
        for a in objattrs:
            if a in attr:
                return (a, 95)
            s = difflib.SequenceMatcher(None, a, attr)
            ratios[s.ratio()] = a
            if reversed is not None:
                s = difflib.SequenceMatcher(None, a, reversed)
                ratios[s.ratio()] = a
        mx = max(ratios.keys())
        return (ratios[mx], 100*mx)

#-------------------------------------------------------------------------------
# End of class _SAXModelGenerator
#-------------------------------------------------------------------------------


class XML2ModelConverter(object):
    """
    Functionality of this class allows to convert file-like object containing
    RRS-XML into hierarchical object model of RRS database (module rrslib.db.model).
    """
    def __init__(self):
        self._handler = _SAXModelGenerator()


    def convert(self, input):
        """
        The input object can be a system identifier (a string identifying the
        input source - typically a file name or an URL), a file-like object, or
        an InputSource object.
        """
        self._handler.init()
        parser = make_parser()
        parser.setContentHandler(self._handler)
        parser.parse(input)
        return self._handler.model

#-------------------------------------------------------------------------------
# End of class XML2ModelConverter
#-------------------------------------------------------------------------------



if __name__ == "__main__":

    from rrslib.db.model import *
    import StringIO
    publ = RRSPublication(title="First publicaation about machine learning")
    publisher = RRSOrganization(title="IEEE society press")
    publ['publisher'] = publisher
    output = StringIO.StringIO()
    conv = Model2XMLConverter(stream=output)
    conv.convert(publ)
    s = output.getvalue()
    output.seek(0)
    print output.read()
    exit()
    #output.seek(0)
    # convert back to model
    conv2 = XML2ModelConverter()
    model = conv2.convert(output)
    #print model[0]

    # and again into XML
    output2 = StringIO.StringIO()
    conv = Model2XMLConverter(stream=output2)
    conv.convert(model)
    s2 = output2.getvalue()

    if s == s2:
        print "Converters OK."
    else:
        print "FAIL. Retry..."
    print s
    #print
    print s2
