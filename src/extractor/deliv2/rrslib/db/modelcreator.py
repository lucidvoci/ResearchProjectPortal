#! /usr/bin/python


"""
ModelCreator converts sql database schema into python ORM.
This script is made to convert SQL Power Architect-generated sql files, it's not
a general sql parser!
"""

import sys
import re
import time
import textwrap
import os.path

__modulename__ = "modelcreator"
__author__ = "Stanislav Heller"
__email__ = "xhelle03@stud.fit.vutbr.cz"
__date__ = "$24.1.2011 12:49:21$"


class PythonModuleGenerator(object):
    """
    General creator of any python object-oriented file. This is no big deal -just
    setting header, imports, classes and its methods. The while script can be
    exported as .py file.
    """

    COMMENT = 0
    METHODS = 1
    ANCESTOR = 2
    CLASSVAR = 3
    INDENT = 4

    def __init__(self):
        self.modulecomment = ""
        self.imports = []
        self.moduleconstants = {}
        self.classes = {}
        self.script = ""
        self.raw_classes = []
        self.main = ""
        self.wrapper = textwrap.TextWrapper(initial_indent=" "*self.INDENT,
                                            subsequent_indent="  "*self.INDENT,
                                            width=80)


    def set_module_comment(self, comment):
        self.modulecomment = comment


    def new_module_constant(self, constant, value):
        self.moduleconstants[constant] = value


    def new_import(self, importstr):
        self.imports.append(importstr)


    def new_class(self, name, comment, ancestor="object", classvar={}):
        self.classes[name] = [comment, {}, ancestor, classvar]


    def new_method(self, classname, methodname, methodcontent):
        self.classes[classname][self.METHODS][methodname] = methodcontent


    def new_raw_class(self, source):
        self.raw_classes.append(source)


    def set_main(self, source):
        self.main = source


    def _wrap_method(self, methodstr):
        r = ""
        splitted = methodstr.split("\n")
        self.wrapper.initial_indent = " "*self.INDENT
        self.wrapper.subsequent_indent = "   "*self.INDENT
        for row in splitted:
            f = self.wrapper.fill(row)
            r += f + "\n"
            self.wrapper.initial_indent="  "*self.INDENT
            self.wrapper.subsequent_indent = "  "*self.INDENT
        return r


    def generate(self):
        self.script = "#! /usr/bin/python\n\n"
        # add comment of module
        self.script += '"""' + self.modulecomment + '\n"""\n\n'
        # add imports
        for _import in self.imports:
            self.script += _import + "\n"
        self.script += "\n\n"
        # add module constants __constant__
        for const in self.moduleconstants:
            self.wrapper.initial_indent = ""
            self.wrapper.subsequent_indent = ""
            if type(self.moduleconstants[const]) is str:
                self.script += self.wrapper.fill(const + " = \"" + self.moduleconstants[const] + "\"") + '\n'
            else:
                self.script += self.wrapper.fill(const + " = " + str(self.moduleconstants[const])) + '\n'
            self.wrapper.initial_indent=" "*self.INDENT
            self.wrapper.subsequent_indent="  "*self.INDENT
        self.script += "\n\n"
        for rc in self.raw_classes:
            self.script += rc
        # add classes and their methods
        for _class in self.classes:
            ancestor = self.classes[_class][self.ANCESTOR]
            methods = self.classes[_class][self.METHODS]
            comment = self.classes[_class][self.COMMENT]
            classvar = self.classes[_class][self.CLASSVAR]
            if comment is None: comment = "No comment available."
            # create class
            self.script += "class " + _class + "(" + str(ancestor) + "):\n"
            self.script += " "*self.INDENT + '"""\n' + " "*self.INDENT + comment + \
                           '\n'+" "*self.INDENT+'"""\n\n'
            for clsvar in classvar:
                if isinstance(classvar[clsvar], basestring):
                    self.script += " "*self.INDENT + clsvar + " = \"" + classvar[clsvar] + "\"\n"
                else:
                    self.script += " "*self.INDENT + clsvar + " = " + str(classvar[clsvar]) + "\n"
            self.script += "\n"
            for methodname in methods:
                self.script += self._wrap_method(methods[methodname])
            self.script += "\n"
            self.script += "#" + 79*"-"
            self.script += "\n# End of class " + _class
            self.script += "\n#" + 79*"-"
            self.script += "\n\n\n"
        self.script += self.main + "\n"
        return self.script


    def get_last_script(self):
        return self.script



class SQLPowerArchitectParser(object):
    """
    SQLPowerArchitectParser parses SQL files generated by open-source modelling
    tool SQL Power Architect. In this program is rrs database created.

    Output of parse() method is made by dictionaries:
    { table : {"attr" : {attributes and types}, "comment" : "comment of table", "j" : {junction tables}}}
    """

    TABLE = "CREATE TABLE [^(]+\([^;]+\);"
    TABLE_COMMENT = "COMMENT ON TABLE [^;]+;"
    COLUMN_COMMENT= "COMMENT ON COLUMN [^;]+;"

    def __init__(self):
        self.tables = {}
        self.j_tables = {}
        self.relationships = {}


    def join_j(self):
        for j in self.j_tables:
            delim = "_"
            if "__" in j:
                delim = "__"
            role = j.split(delim)[-1]
            # if role is in tables (the last word in table name was also table)
            # the relation doesnt have any role
            for tname in self.tables.keys():
                if tname.startswith(role):
                    role = None
                    break
            pk_list = self.j_tables[j]["pks"]
            if pk_list is None:
                continue
            tables = []
            for x in pk_list:
                if x.endswith("_id"):
                    tables.append(x[:-3])
            rel_attr = self.j_tables[j]["attr"]
            for fk_id in pk_list:
                if not fk_id.endswith("_id"): continue
                del rel_attr[fk_id]
            if not len(rel_attr):
                rel_attr = None
            for t in tables:
                self.tables[t]["j"].append(( tuple(set(tables).difference(set([t]))), role))
            key = tuple(set(tables))
            if not key in self.relationships:
                self.relationships[key] = [(rel_attr, role, j, False)]
            else:
                self.relationships[key].append((rel_attr, role, j, False))



    def clean_row(self, r):
        r = re.sub("[ \n\t]+", " ", r)
        for i in (" ", "\n", "\t"):
            r = r.rstrip(i).lstrip(i)
        return r


    def get_table_attributes(self, tabletxt):
        plain = re.sub("[ \t]+", " ", tabletxt)
        content = re.search("(?<= \()[^;]+(?=\);)", plain).group(0)
        attributes = content.split(",\n")
        r = {}
        pks = None
        for a in attributes:
            a = self.clean_row(a)
            keyw = a.split(" ")
            if keyw[0] == "UNIQUE": continue
            if keyw[0] == "CONSTRAINT":
                pks = re.search("(?<=\()[^\)]+(?=\))", a).group(0)
                if "," in pks:
                    pks = pks.split(", ")
                else:
                    pks = [pks]
                continue
            if len(keyw) == 1: continue
            if keyw[1].startswith("NUMERIC"): keyw[1] = "NUMERIC"
            r[keyw[0]] = keyw[1]
        return r, pks


    def get_tables(self):
        # get all tables and junction tables
        tablelist = re.findall(self.TABLE, self.sql)
        for t in tablelist:
            try:
                tablename = re.search("(?<=data\.)[^( ]+(?= \()", t).group(0)
            except re.error:
                continue
            attr, pks = self.get_table_attributes(t)
            # is this junction table?
            if tablename.startswith("j_"):
                self.j_tables[tablename] = {'attr':attr, 'comment': None, "pks":pks}
            else:
                self.tables[tablename] = {'attr' : attr, 'comment': None, 'j' : [], "pks":pks}


    def get_comments(self):
        # get table comments
        comentlist = re.findall(self.TABLE_COMMENT, self.sql)
        for c in comentlist:
            c = c[22:]
            table, comment = c.split(" IS ")
            comment = comment.lstrip("'").rstrip("';")
            if table in self.tables:
                self.tables[table]["comment"] = comment


    def parse(self, instream):
        # processing
        self.sql = instream.read()
        self.get_tables()
        self.join_j()
        self.get_comments()
        return self.tables, self.relationships



class RRSModelCreator(object):
    """
    Model creator parses power architect sql file and creates new python
    file containing psudo-ORM layer between RRS-module a RRS-XML.
    """
    model_raw = """
class RRSDatabaseEntityError(Exception):
    pass

class RRSDatabaseAttributeError(AttributeError):
    pass

class RRSDatabaseValueError(ValueError):
    pass


#-------------------------------------------------------------------------------
# End of classes RRSDatabaseError
#-------------------------------------------------------------------------------


class RRSDatabaseEntityChecker:
    \"\"\"
    The methods checks if attribute in table gets the right type of value. For example:
    If event has an attribute "location" (in fact in database it has only location_id FK)
    location has to be type of RRSLocation.
    \"\"\"


    @classmethod
    def check_credibility(self, value):
        if isinstance(value, int) and value >= 0 and value <= 100: return
        if value is None: return
        raise RRSDatabaseValueError("Credibility has to be type integer in range 0 - 100")

    @classmethod
    def check_link(self, value):
        if value is None: return
        if not isinstance(value, (str, unicode)):
            raise RRSDatabaseValueError("Link (URL) has to be type string")
        # XXX Uniform Resource Identifier (URI) regex specified in RFC 2396:
        #  ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
        # which of them we have to use?
        rfc2396_url = '^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$'
        if not re.match(rfc2396_url, value):
            raise RRSDatabaseValueError("Link format doesn't agree with RFC 2396 specification")

#-------------------------------------------------------------------------------
# End of classes RRSDatabaseEntityChecker
#-------------------------------------------------------------------------------




# parent class of all database tables (entities)
class _RRSDatabaseEntity(object):
    \"\"\"
    _RRSDatabaseEntity is top-level class, it's parent of all database-entity classes.
    Implements also method __str__ which is common for all descendants.
    \"\"\"

    lev = 0 # Indent storage. Needed when __str__() method is called.

    def __init__(self, id):
        self.id = None
        self.credibility = None
        self.module = None

        # primary key of every entity (table) in database
        self.set('id', id)
        self.set('credibility', None)
        self.set('module', None)


    def get(self, attr):
        \"\"\"
        Returns requested attribute. If attribute doesn't exist, throws Exception.
        \"\"\"
        return getattr(self, attr)


    def set(self, attr, val, strict=True):
        \"\"\"
        Assigns value $val to attribute $attr. Throws RRSDatabaseValueError if
        trying to set inappropriate value (wrong format) and RRSDatabaseEntityError
        when trying to set wrong entity (in juncion table).
        This way we try to avoid setting malformated data into the database.
        Method can also avoid direct recursion (inserting object to himself), but
        cannot recognize indirect recursion like A.insert(B); B.insert(A).
        \"\"\"
        if val is None:
            return
        if isinstance(val, basestring):
            if not len(val): return False
            s = re.sub(\"[\\n\\t\\r ]+\", \"\", val)
            if not len(s): return False
        if val is self:
            raise RRSDatabaseValueError("Avoid infinite recursion: Cannot insert itself as a value.")

        # Check type. If it is some new attribute, the type cannot be determined
        if attr in self.__types__:
            if self.__types__[attr] is not _UnknownType:
                self._check_type(attr, val, self.__types__[attr])
        else:
            try:
                if type(self.__dict__[attr]) is not list:
                    self.__types__[attr] = _UnknownType
            except KeyError, e:
                if strict:
                    cls = str(self.__class__).split("'")[1].split(".")[-1]
                    raise KeyError("Object %s has no attribute %s." % (cls, e))
                else:
                    self.__types__[attr] = _UnknownType
                    # no semanics checking needed, so insert value into object
                    setattr(self, attr, val)
                    return

        # Check semantics
        self._check_semantics(attr, val)

        # Insert
        if type(self.__dict__[attr]) == list:
            if not isinstance(val, _RRSDbEntityRelationship):
                raise RRSDatabaseValueError("Relationship between entities has to" \\
                "be represented by any instance of subclass of _RRSDbEntityRelationship")
            val._parent = self # set pointer to parent element
            self.__dict__[attr].append(val)
        else:
            setattr(self, attr, val)


    def isset(self, attr):
        \"\"\"
        This function returns True if attribute is set and not None. Else retuns
        False.
        \"\"\"
        try:
            _var = getattr(self, attr)
        except:
            return False
        if isinstance(_var, list):
            return len(_var) > 0
        return _var is not None


    def _check_type(self, attr, val, _type):
        \"\"\"
        Checks attribute for correct value type.
        \"\"\"
        if not isinstance(val, _type):
            raise RRSDatabaseValueError(\"Attribute \" + attr + \" has to be type \" \\
            + str(_type))


    def _check_semantics(self, attr, val):
        \"\"\"
        Iterates over methods in checker and tests attribute for correct value type.
        Some of checking methods are heuristic.
        \"\"\"
        for method in dir(RRSDatabaseEntityChecker):
            if callable(getattr(RRSDatabaseEntityChecker, method)):
                if method.replace("check_", "") == attr.split('_')[0]:
                    getattr(RRSDatabaseEntityChecker, method)(val)
                    break


    def _deleted(self, obj, parent, attr):
        if obj.empty(exc=['id']):
            if parent is None and attr is None:
                return False # do nothing, its the top-level object
            else:
                assert parent is not None
                assert attr is not None
                if type(parent[attr]) is list:
                    # iterate over all relationship objects and delete the right
                    for i, rel_obj in enumerate(parent[attr]):
                        for ent in rel_obj.get_entities():
                            if ent is obj:
                                del parent[attr][i]
                                return True
                else:
                    # it is normal
                    setattr(parent, attr, None)
                    return True
            return True
        return False


    def _compile(self, parent, attr, c):
        if parent is None or attr is None:
            # the first level
            obj = self
        else:
            obj = parent[attr]
        # is this a relationship?
        if isinstance(obj, list):
            for rel_obj in obj:
                for e in rel_obj.get_entities():
                    if self._deleted(e, parent, attr):
                        continue
                    if e in c: return
                    c.append(e)
                    for item in e:
                        self._compile(e, item, c)
        # base entity (instance o subclass of RRSDatabseEntity
        elif isinstance(obj, _RRSDatabaseEntity):
            if self._deleted(obj, parent, attr):
                return
            if obj in c: return
            c.append(obj)
            for item in obj:
                self._compile(obj, item, c)


    def compile(self):
        \"\"\"
        Compile the entity tree. It means, all empty objects are removed, all
        relationship are checked for cyclic dependencies - the graph has to be
        acyclic (tree).
        If some cycle found, raises RRSDatabaseEntityError exception.
        @returns count of compiled objects
        \"\"\"
        c = [] # container for objects. Find out if there is any cyclic dep.
        self._compile(None, None, c)
        return len(c)


    def _str_helper(self, attr, c):
        if attr in c:
            return "None"
        if isinstance(attr, (int, basestring, complex, float, list)):
            return str(attr)
        if attr is None:
            return "None"
        c.append(attr)
        s = "<" + __modulename__ + "." + str(attr.__class__).split("'")[1].split(".")[-1] + "("
        l = len(s)
        _RRSDatabaseEntity.lev += l
        # looping over all variables in instance
        for var in attr.__dict__:
            # get value of variable
            att = attr.__dict__[var]
            #att = getattr(self, var)
            # attribute mustn't be callable and mustn't be in __underscored__ fashion
            if not callable(att) and not var.startswith("__") and not var.endswith("__") \\
                and var not in ('event_types', 'publication_types', 'url_types',\\
                'organization_types', 'lev', 'location_types', 'project_types', 'modules'):
                # if attribute is string, arr quotes to make it better readable
                conn = ""
                if isinstance(att, basestring): conn = '"'
                # add attribute to representation of object
                s += (var + "=" + conn + self._str_helper(att, c)) + conn +", \\n" + _RRSDatabaseEntity.lev*" "
        s = s[0:-2]
        _RRSDatabaseEntity.lev -= (l)
        return s + "), instance ID=" + str(id(self)) + ">"


    def __str__(self):
        \"\"\"
        Returns textual representation of database entity if format:
        <rrsdbdata._RRSDatabaseEntity(id=None), instance ID=3075444236>
        this method inherite all subclasses and there's not need to override it.
        \"\"\"
        c = []
        return self._str_helper(self, c)


    def get_own_attrs(self):
        \"\"\"
        Returns dictionary mapping own attributes to non-null values. Own
        attributes are non-FK columns of table. The non-null value is ment to be
        value != None.
        \"\"\"
        d = {}
        for attr in self.__types__:
            if attr in ("module", "credibility"): continue
            if self.__types__[attr] in (int, float, basestring, str, unicode,
                                        RRSDateTime, RRSEmail):
                if self.isset(attr):
                    d[attr] = self.get(attr)
        return d


    def empty(self, exc=[]):
        \"\"\"
        Returns true if no value assigned to object, thus it's interpreted as empty.
        @param exc - all except these attributes will be counted to empty state
                     If an attribute in exc-list will be present, it's counted
                     as non-existent.
        \"\"\"
        attrs = self.get_own_attrs()
        return not set(attrs.keys()).difference(set(exc))


    # Container emulation

    def __getitem__(self, key):
        if not isinstance(key, basestring):
            raise TypeError("Key is of an inappropriate type. Has to be type string or unicode.")
        return self.get(key)


    def __setitem__(self, key, value):
        self.set(key, value)


    def __contains__(self, item):
        return self.isset(item)


    def __iter__(self):
        for attr in self.__dict__:
            if attr in ("_table_name", "__types__", "lev"):
                continue
            yield attr


#-------------------------------------------------------------------------------
# End of class _RRSDatabaseEntity
#-------------------------------------------------------------------------------


class _UnknownType(object):
    def __str__(self):
        return "Unknown type"

    def __repr__(self):
        return "Unknown type"

    def __setattr__(self, attr, value):
        raise Exception("Cannot set attribute to unknown type")

    def __getattr__(self, attr):
        raise Exception("Cannot get attribute from unknown type")

#-------------------------------------------------------------------------------
# End of class _UnknownType
#-------------------------------------------------------------------------------


############################ non-database entities #############################
# these arent inherited from _RRSDatabaseEntity, but they are implemented for
# typechecking

class RRSDateTime(object):
    \"\"\"
    There was a need to have universal datetime object with possibility to be
    empty and half-specified (which neither time_struct, nor datetime.date or
    datetime.datetime support). Also we need often to get timestamp - usual library
    classes in module datetime doesn't provide methods for achieve it.

    So here is class implemented to acomplish these needs.
    \"\"\"
    # FIXME check days in month - where is 30 and where 31 days (in February 28,29).

    def __init__(self, year=None, month=None, day=None, hour=None, minute=None, \\
                       second=None):
        self._content = {'year': None, 'month': None, 'day': None, \\
                         'hour': None, 'minute': None, 'second': None}
        self.set('year', year)
        self.set('month', month)
        self.set('day', day)
        self.set('hour', hour)
        self.set('minute', minute)
        self.set('second', second)


    def get(self, attr):
        \"\"\"
        Get time parameter. If asking for invalid parameter, Exception is thrown.
        \"\"\"
        return self._content[attr]


    def set(self, attr, val):
        # there can be inserted None too
        if val is None and attr in self._content:
            self._content[attr] = val
            return
        # attributes has to be type integer
        if not isinstance(val, int):
            raise RRSDatabaseValueError(str(attr)+" has to be type integer or NoneType")

        # checking ranges
        if attr == 'year':
            if val > 2100 or val < 1900:
                raise RRSDatabaseValueError("year has to be integer in range 1900-2100")
        elif attr == 'month':
            if val > 12 or val < 1:
                raise RRSDatabaseValueError("month has to be integer in range 1-12")
        elif attr == 'day':
            if val > 31 or val < 1:
                raise RRSDatabaseValueError("day has to be integer in range 1-31")
        elif attr == 'hour':
            if val > 23 or val < 0:
                raise RRSDatabaseValueError("hour has to be integer in range 0-23")
        elif attr == 'minute' or attr == 'second':
            if val > 59 or val < 0:
                raise RRSDatabaseValueError(str(attr)+" has to be integer in range 0-59")
        else:
            raise RRSDatabaseAttributeError("Attribute for RRSDateTime not appropriate: "+str(attr))

        # set value to the content dict
        self._content[attr] = val


    def parse_isoformat(self, val):
        \"\"\"
        Parses date in ISO 8601 format and stores into object.
        \"\"\"
        date, time = None, None
        if ' ' in val:
            (date, time) = val.split(' ')
        elif '-' in val: date = val
        else: time = val
        if date is not None:
            sp = date.split('-')
            self.set('year', int(sp[0]))
            if len(sp) > 1:
                self.set('month', int(sp[1]))
            if len(sp) > 2:
                self.set('day', int(sp[2]))
        if time is not None:
            (h,m,s) = time.split(':')
            self.set('hour', int(h))
            self.set('minute', int(m))
            self.set('second', int(s))


    def parse_timestamp(self, timestamp):
        \"\"\"
        Parses date from timestamp and stores into object.
        \"\"\"
        dd = datetime.datetime.fromtimestamp(timestamp)
        self.set('year', dd.year)
        self.set('month', dd.month)
        self.set('day', dd.day)
        self.set('hour', dd.hour)
        self.set('minute', dd.minute)
        self.set('second', dd.second)


    def now(self):
        \"\"\"
        Set object's date and time as NOW.
        \"\"\"
        self.parse_timestamp(time.time())


    def timestamp(self):
        \"\"\"
        Method timestamp() returns time in second since epoch (1.1.1970). If
        year is below 1970, method returns 0.0.

        If some of params are missing, all lower-level params are ignored.
        Example (day is missing):
        \>>> t = RRSDateTime(year=1971, month=2)
        \>>> print t.timestamp()
        34210800.0
        \>>> t.set('hour', 12)
        \>>> print t.timestamp()
        34210800.0
        \"\"\"
        def get_tstp(y,mo,d,h,mi,s):
            ts = time.strptime(str(y)+'-'+str(mo)+'-'+str(d)+'T'+str(h)+':'+\\
                               str(mi)+':'+str(s), '%Y-%m-%dT%H:%M:%S')
            return time.mktime(ts)
        y = 1970
        mo = 1
        d = 1
        h = 0
        mi = 0
        s = 0
        # syntacic hack - 'while' stmt is not important, but 'break' makes there goto stmt
        while 1:
            if self._content['year'] is None: break
            y = self._content['year']
            if self._content['month'] is None: break
            mo = self._content['month']
            if self._content['day'] is None: break
            d = self._content['day']
            if self._content['hour'] is None: break
            h = self._content['hour']
            if self._content['minute'] is None: break
            mi = self._content['minute']
            if self._content['second'] is None: break
            s = self._content['second']
            break
        if y < 1970: return 0.0
        return get_tstp(y,mo,d,h,mi,s)


    def date_isoformat(self):
        \"\"\"
        This format is an international standard ISO 8601 for date, which describes
        date in order year-month-day.
        \"\"\"
        s = ''
        for att in ('year', 'month', 'day'):
            if self._content[att] is None:
                return s.rstrip("-")
            s += str(self._content[att]) + '-'
        return s.rstrip("-")


    def time_isoformat(self):
        \"\"\"
        This format is an international standard ISO 8601 for time, which describes
        time in order hour:minute:second.milisecond.
        \"\"\"
        s = ''
        for att in ('hour', 'minute', 'second'):
            if self._content[att] is None:
                return s.rstrip(":")
            s += str(self._content[att]) + ':'
        return s.rstrip(":") + ".0"



    def datetime_isoformat(self):
        \"\"\"
        This format is an international standard ISO 8601, which describes date
        in order year-month-day hour:minute:second.milisecond.

        This method returns ISO 8601 format, but if we do not have enought informations,
        i.e. day is missing, method returns only year-month. All params behind
        (hour, minute, second) are siply ignored, because if some higher-level
        param is missing, lower-level informations becomes useless.
        \"\"\"
        date = self.date_isoformat()
        if not re.search("\d{4}\-\d{1,2}\-\d{1,2}", date):
            return date
        time = self.time_isoformat()
        if not re.search("\d{1,2}:\d{1,2}:\d{1,2}", time):
            return date
        return date + ' ' + time


    def __str__(self):
        return self.datetime_isoformat()

#-------------------------------------------------------------------------------
# End of class RRSDateTime
#-------------------------------------------------------------------------------


class RRSEmail(object):
    \"\"\"
    RRSEmail was created just for typechecking of inserted e-mail like data.
    There is strong regular expression control, if e-mail address is in the
    right format and agrees with RFC 5322 specification.
    \"\"\"
    def __init__(self, email=None):
        self._localpart = None
        self._domain = None
        self.set_email(email)


    def set_email(self, mailstr):
        if mailstr is not None:
            if re.search('^[a-zA-Z0-9!#$%&\\\'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&\\\''\\
            '*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+('\\
            '?:[a-zA-Z]{2}|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|'\\
            'mobi|museum|name|net|org|pro|tel|travel)', mailstr):
                self._localpart, self._domain = mailstr.split('@')
            else:
                raise RRSDatabaseValueError("Wrong e-mail format."+str(mailstr))

    def get_localpart(self):
        return self._localpart


    def get_domain(self):
        return self._domain


    def __str__(self):
        return self._localpart + "@" + self._domain

#-------------------------------------------------------------------------------
# End of class RRSEmail
#-------------------------------------------------------------------------------


class _RRSDbEntityRelationship(object):
    def __init__(self):
        self._entities = []
        self._parent = None


    def set_attribute(self, name, val):
        setattr(self, name, val)


    def set_entity(self, val):
        if type(val) in self.__types__["__entities__"]:
            self._entities.append(val)
        else:
            obj = repr(val).split(".")[1].split(" ")[0] + " object"
            this = repr(self).split(".")[1].split(" ")[0] + " object"
            raise RRSDatabaseEntityError("Cannot set " + obj + " into " + this)


    def isset(self, attr):
        \"\"\"
        This function returns True if attribute is set and not None. Else retuns
        False.
        \"\"\"
        try:
            _var = getattr(self, attr)
        except:
            return False
        if isinstance(_var, list):
            return len(_var) > 0
        return _var is not None


    def get_attribute(self, attr):
        return getattr(self, attr)


    def get_entities(self):
        return self._entities

    # Container emulation

    def __getitem__(self, key):
        if not isinstance(key, basestring):
            raise TypeError("Key is of an inappropriate type. Has to be type string or unicode.")
        return self.get_attribute(key)


    def __setitem__(self, key, value):
        self.set_attribute(key, value)


    def __contains__(self, item):
        return self.isset(item)


    def __iter__(self):
        for attr in self.__dict__:
            if attr in ("_table_name", "__types__", "_parent", "_entities"):
                continue
            yield attr


    def __str__(self):
        s = str(self.__class__).split("'")[1].split(".")[-1] + "\\n"
        for e in self._entities:
            s += str(e)
        return s

#-------------------------------------------------------------------------------
# End of class _RRSDbEntityRelationship
#-------------------------------------------------------------------------------


"""

    def __init__(self):
        self.fout = None
        self.fin = None
        self.sqlparser = SQLPowerArchitectParser()
        self.generator = PythonModuleGenerator()


    def set_output_file(self, filename):
        self.fout = open(filename, 'w')


    def set_input_file(self, filename):
        self.fin = open(filename, 'r')


    def _rrscls(self, _class):
        return "RRS" + _class[0].upper() + _class[1:]


    def _translate_sql_to_python_type(self, sqltype):
        if sqltype in ("INTEGER", "NUMERIC", "SMALLINT", "MEDIUMINT", "LONGINT", "SERIAL"):
            return "int"
        elif sqltype in ("DOUBLE", "REAL"):
            return "float"
        elif sqltype in ("DATE", "TIMESTAMP", "DATETIME"):
            return "RRSDateTime"
        elif sqltype.startswith("VARCHAR"):
            return "basestring"
        elif sqltype.startswith("CHAR"):
            return "basestring"
        elif sqltype in ("TEXT", "LONGTEXT", "CHAR"):
            return "basestring"
        elif sqltype == "BOOLEAN":
            return "bool"


    def _gen_table_init(self, instance_vars, junction_tables, class_):
        """
        Generate __init__ method = constructor.
        """
        # init string
        s = "def __init__(self"
        # variable types
        d = "# dictionary of variable types \nself.__types__ = {"
        # attributes
        i = "# attributes\n"
        # value setter
        sv = "# set values\n"
        for var in instance_vars:
            if var == "credibility": continue
            vartype = self._translate_sql_to_python_type(instance_vars[var])
            if var == "email":
                vartype = "RRSEmail"
            if var == "publisher_id":
                vartype = "RRSOrganization"
                var = "publisher"
                d += "\'" + var + "\':" + vartype + ", "
                s += ", " + str(var) + "=None"
                # set value to the variable
                sv += "self.set(\"" + var + "\", " + var + ")\n"
                i += "self." + var + " = None\n"
            # is this this reference (FK) to other table?
            elif "_id" in var:
                tbl, role = var.split("_id")
                prefix = ""
                if tbl == "parent":
                    cls = self._rrscls(class_)
                else:
                    if tbl in self.tablenames:
                        cls = self._rrscls(tbl)
                    else:
                        if "_" in tbl:
                            prefix, tbln = tbl.split("_")
                            prefix += "_"
                            if tbln in self.tablenames:
                                cls = self._rrscls(tbln)
                                tbl = tbln
                            else:
                                cls = self._rrscls(class_) + "_" + tbl
                        else:
                            cls = self._rrscls(class_) + "_" + tbl

                par_entity = (cls[3:]).lower()
                key = tuple(
                                set(
                                    (class_, par_entity)
                                   )
                           )
                # TODO publication publication_section -> do not [:4]!!
                jtblname = "j_" + par_entity[:4] + "_" + class_[:4]
                val = [(None, None, jtblname, True)]
                if par_entity != class_ and not key in self.relationships:
                    self.relationships[key] = val

                i += "self." + prefix + tbl + role + " = None\n"
                d += "\'" + prefix + tbl + role + "\':" + cls + ", "
            else:
                # add type
                d += "\'" + var + "\':" + vartype + ", "
                s += ", " + str(var) + "=None"
                # set value to the variable
                sv += "self.set(\"" + var + "\", " + var + ")\n"
                if var != "id":
                    i += "self." + var + " = None\n"

        #junction tables
        for j in junction_tables:
            role = ""
            if j[1] is not None:
                role = "_" + j[1]
            for v in j[0]:
                i += "self." + v + role + " = []\n"

        # end it
        for var in (("module","basestring"),("credibility","int")):
            d += "\'" + var[0] + "\':" + var[1] + ", "
        s += "):\n"
        s += i
        s += "\n" + d.rstrip(", ") + "}\n"
        if "id" in instance_vars.keys():
            s+= "\n# call constructor of ancestor\n_RRSDatabaseEntity.__init__(self, id)\n\n"
        s += sv
        return s


    def _gen_jtable_init(self, instance_vars, entities):
        # init string
        s = "def __init__(self"
        # variable types
        d = "# dictionary of variable types \nself.__types__ = {\'__entities__\':("
        for ent in entities:
            vartype = self._rrscls(ent)
            d += vartype + ", "
        d = d.rstrip(", ") + "), "

        # attributes
        i = "# attributes\n"
        # value setter
        sv = "# set values\n"
        if instance_vars is not None:
            for var in instance_vars:
                vartype = self._translate_sql_to_python_type(instance_vars[var])
                if var == "email":
                    vartype = "RRSEmail"

                d += "\'" + var + "\':" + vartype + ", "
                s += ", " + str(var) + "=None"
                # set value to the variable
                sv += "self.set_attribute(\"" + var + "\", " + var + ")\n"
                i += "self." + var + " = None\n"
            s += "):\n"
            s += i
            s += "\n" + d.rstrip(", ") + "}\n"
            s+= "\n# call constructor of ancestor\n_RRSDbEntityRelationship.__init__(self)\n\n"
            s += sv
            return s
        else:
            s += "):\n"
            s += "\n" + d.rstrip(", ") + "}\n"
            s+= "# call constructor of ancestor\n_RRSDbEntityRelationship.__init__(self)\n"
            return s


    def _add_fk_relationships(self):
        for class_ in self.tables:
            if class_.startswith("RRS_DB") or class_.endswith("_meta") or class_ == "temp_tables":
                continue
            instance_vars = self.tables[class_]["attr"]
            for var in instance_vars:
                if var == "publisher_id":
                    vartype = "RRSOrganization"
                    var = "publisher"
                    # TODO action?
                elif "_id" in var:
                    tbl, role = var.split("_id")
                    if tbl == "parent":
                        continue
                    if tbl in self.tablenames:
                        if role == "":
                            role = None
                        else:
                            role = role.lstrip("_")
                        self.tables[tbl]["j"].append( ((class_,), role) )
                    else:
                        if "_" in tbl:
                            prefix, tbln = tbl.split("_")
                            if prefix.endswith("ed"): # reference...referenced
                                prefix = prefix.rstrip("d")
                            if tbln in self.tablenames:
                                self.tables[tbln]["j"].append( ((class_,), prefix) )



    def generate_model(self):
        self.generator.set_module_comment(
        """
This module should be a programatical mirror of rrs database data model - classes
are tables, instance variables are attributes, class variables are enums of entity
types.

THIS FILE IS GENERATED BY rrslib.db.modelcreator.py. Any mistakes have to be fixed
there.""")

        self.generator.new_module_constant("__modulename__", "model")
        self.generator.new_module_constant("__author__", "RRSModelCreator")
        self.generator.new_module_constant("__date__", "$"+time.ctime()+"$")
        self.generator.new_import("import time")
        self.generator.new_import("import datetime")
        self.generator.new_import("import re")
        self.generator.new_raw_class(self.model_raw)
        # parse sql file
        self.tables, self.relationships = self.sqlparser.parse(self.fin)
        self.fin.close()
        self.tablenames = self.tables.keys()
        self.generator.new_module_constant("__tables__", tuple(self.tablenames))
        # add fk attrs from relationships 1:N
        self._add_fk_relationships()
        # create mapping table -> base object (base class)
        for class_ in self.tables:
            if class_.startswith("RRS_DB"):
                self.generator.new_module_constant("__dbversion__", class_)
                continue
            if class_.endswith("_meta") or class_ == "temp_tables":
                continue
            classname = self._rrscls(class_)
            self.generator.new_class(classname, self.tables[class_]["comment"], "_RRSDatabaseEntity", {"_table_name" : class_})
            instance_vars = self.tables[class_]["attr"]
            junction_tables = self.tables[class_]["j"]
            method_string = self._gen_table_init(instance_vars, junction_tables, class_)
            self.generator.new_method(classname, "__init__", method_string)



        def create_rel_class_name(entities, tablename, role):
            indexes = {}

            for ent in entities:
                if tablename.index(ent[:4]) in indexes:
                    e1 = indexes[tablename.index(ent[:4])]
                    e2 = ent
                    return "RRSRelationship" + e1[0].upper() + e1[1:].lower() + \
                                               e2[0].upper() + e2[1:].lower()
                else:
                    indexes[tablename.index(ent[:4])] = ent
            namestr = "RRSRelationship"
            while len(indexes):
                first_ent = min(indexes.keys())
                e = indexes[first_ent]
                namestr += e[0].upper() + e[1:]
                del indexes[first_ent]
            if role is None:
                return namestr
            return namestr + role[0].upper() + role[1:]


        # create mapping junction-table -> relationship object (class)
        for rel_entities in self.relationships:

            tuple_list = self.relationships[rel_entities]
            for t in tuple_list:
                attr, role, tablename, fake = t
                clsname = create_rel_class_name(rel_entities, tablename, role)
                self.generator.new_class(clsname, "No comment available.",
                        "_RRSDbEntityRelationship", {"_table_name" : tablename, "_fake_table" : fake})
                method_string = self._gen_jtable_init(attr, rel_entities)
                self.generator.new_method(clsname, "__init__", method_string)

        # generate result python script
        model = self.generator.generate()
        print model
        #self.fout.write(model)
        #self.fout.close()



def parse_cmd():
    if len(sys.argv) < 2:
        print("Not enough prameters.")
        exit(1)
    if sys.argv[1] == "-h":
        print "modelcreator.py"
        print "run ./modelcreator.py output_model"
        exit(0)
    if os.path.isfile(sys.argv[1]):
        print("Cannot write to existing file")
        exit(1)


if __name__ == "__main__":
    parse_cmd()
    creator = RRSModelCreator()
    #creator.set_output_file(sys.argv[1])
    creator.set_input_file("/media/Data/Skola/FIT/prace/NLP/db09/rrs_db-09-release.sql")
    creator.generate_model()

